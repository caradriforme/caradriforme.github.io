<head>
	<link rel="stylesheet" href="stylesheet.css">
	<title>One: Assembly Structure & Intermediate Passes</title>
</head>

<body>
	<h2>Assembly Structure: Designing the syllabus</h2>
	
	<p>Often, if not always, <b>your syllabus is a prospective student's first point of contact with your course</b>. With that in mind, it should be written not just to help your current students frantically scour the assignment requirements during late-night coding sessions, but for freshmen and sophomores who find themselves dreaming of a course where they might actually learn something about how programming works. 
	<br><br>
	Let's talk about what that means. Sure, your assignments should be detailed and clear about what is expected, but they should also establish the goals of each one. The most common refrain I've encountered as a teaching assistant is "why do we have to do this?" Making that clear up-front will massively reduce frustration on behalf of anyone who reads your syllabus. Linking those goals back to the overall course structure is another key. Not only are you saying "this is what you'll learn by doing this", but you're also saying "this is why learning that is important". Any student who comes to you complaining that they don't know why you're doing something in class very obviously hasn't read your syllabus after that!
	<br><br>
	Especially when planning such a project-heavy course, the question of whether to require a textbook becomes an important one. (Sure, you could teach a compilers course without having a central project, but the amount of theory that would be involved would pretty quickly take the course away from the central focus and into the realm of something like programming language theory or software design.) What, exactly, are the considerations involved?
	<ul>
		<li> Students can reference the exact material they need at all times, without asking you</li>
		<li> You can give students the ability to learn more about topics you might not cover in class</li>
		<li> Plus, if you make them buy it more money goes to compiler textbook authors (do not actually do this)</li>
	</ul>
	While the second item is important, the first one can be almost entirely resolved by a well-written syllabus! If your syllabus is properly organized, your students will be able to find the information they need with ease. In the meantime, you can link or refer to materials that you think can provide a greater level of detail... in your syllabus :)
	<br><br>
	Speaking of projects. Your course will probably be based around a central project - well, a compiler - but leaving the project the same year over year could very easily lead to code duplication and cheating. This is why most CS courses - especially intro-level ones - tend to rotate their projects quite often, and they still can't manage to completely avoid plagiarism while doing it! It is easiest, therefore, if your students are allowed to choose their own final projects, as long as you get final approval. You don't want someone biting off more than they can chew and trying to convert their entire compiler to a different architecture (ask me how I know). Of course, that means you can't be too detailed about the project in your syllabus, but you can do something - give examples of prior projects that students have successfully completed, or (more entertainingly) examples of project proposals that were <i>way</i> too easy or <i>wayyy</i> too hard to be suitable.
	<br><br></p>
	
	<h2>Intermediate Passes: Introducing the course structure</h2>
	
	<p>So you've written your syllabus, and you feel pretty confident about it. <b>How can you introduce it to your students?</b> You <i>could</i> take the easy route of just posting it on Canvas and turning off your computer for the weekend, but especially in a higher-level class spending a class going over the syllabus lets you make sure all your students are starting on the same level and have the same understanding of what a compiler does. This is of course dependent on the intricacies of your course schedule; if you have to worry about getting through all your material over the course (haha) of the semester it might not be advisable to burn a whole day on the syllabus. 
	<br><br>
	The structure of a compiler (as mirrored by the structure of this series of articles) is fairly straightforward - lexer/parser, syntax checker, intermediate representation, optimization, assembly code generation, and linking. (This section plays the role of optimization in such a pipeline, by the way.) It's certainly possible to go step-by-step, spending a week or two per phase. First you write a really good lexer and parser, then a really good syntax system, and so on. The problem with this is that in doing so you lose a lot of the inherent understanding of the connections between each compiler component. Sure, you can perfect each individual phase, but after you finish one phase you have to start writing another from scratch, which means you're connecting your perfected phase with your first-effort next phase. 
	<br><br>
	A better approach, considering, would be to write a lot of bad compilers. You start with a first-effort attempt on each phase, roughly at the same time, and then iteratively improving the whole pipeline bit by bit. In doing so, you maintain the understanding of the connections between the phases while also allowing for improvements across the entire project. This does, however, complicate the pedagogical structure of the course. After all, rather than being able to focus on each individual phase of the compiler and perfect it, you have to find a way to incrementally improve the whole thing week-over-week. This often ends up requiring you to "railroad" (restrict to a narrow set of predetermined options) your course, since the compiler needs to be carefully improved in a way that allows you to build on it further. 
	<br><br>
	Once you've described the course as a whole, you can get into the topic of the final project. This will often be a daunting proposition for your students - at the beginning of the course, many of them have just learned how a compiler works! But describing the prospect of the final project from the get-go will allow students to start thinking about what they might want to implement for their final project as they encounter interesting ideas during the development process. Telling people "sure we'll have a final project but don't worry about that now" will only lead to stress and frustration when you announce with six weeks left "so you should all start thinking about your final project now." Running into an interesting technicality or noticing something in the textbook and wanting to explore it more is exactly what the final project should be for.
	<br><br>
	The last topic is that of examinations. This is a little more contentious than a final project. After all, if you're giving students a course-long project to work on, the last thing they'll want to hear is that they also have two midterms and a final. Given, especially, the relatively low concentration of information that can be absorbed through rote memorization in a compilers course, you can't exactly give a multiple-choice exam. There are a number of other options - a short paper, timed short-answer exams, peer code review - and the critical part is deciding what will work best for your particular students and course structure.
	</p>
</body>
