<head>
	<link rel="stylesheet" href="stylesheet.css">
	<title>Three: Syntax Checking & Lexing and Parsing</title>
</head>

<body>
	<h2>Syntax Checking: Grading final projects</h2>
	
	<p>The semester is winding down, students are turning in their final projects one by one, and now comes the most subjective part of the whole course - <b>How do you fairly grade projects that differ so dramatically in topic and execution?</b> Ideally, they don't differ <i>too</i> harshly in scope - that is, if you did well enough at tempering their expectations so that they picked an appropriately sized project, they should all have accomplished roughly the same amount of work, even if the specific directions they took that work vary massively. 

	<br><br>

	This is where the subjective part of grading comes in. On the one hand, you've given each student the chance to choose a project that should be, roughly speaking, accomplishable in the time provided. On the other hand, different students will have expertise in different fields, and if a student chose an area where they're weak it'll have been difficult for them to make significant progress. The critical point here - and really, this goes beyond this class and into broader pedagogical concepts as a whole - is to do your best to reward effort rather than execution. There are obviously common-sense limitations to this! If someone tries really hard and accomplishes very little they should not be getting an A on the assignment. You want to see <i>something</i> at the end of the day. However, given the point of a capstone topic like compilers, it is absolutely possible - hell, even likely - that you will have students who wrote a ton of code for their project but couldn't get it to run. (Ask me how I know.)

	<br><br>

	What's more, it's important not to weight the final project too heavily. To get to the point where they can consider adding a project-scale extension onto their code, your students will have written an entire compiler by themselves! That's a remarkable achievement. This doesn't necessarily need to be factored into how you grade the final project, but your grading for the course as a whole should absolutely take into account the work done along the way to the final project. By the same token, a student who struggles to assemble their compiler properly will <i>of course</i> struggle in their final project - they don't have a good foundation to build off of! Taking into account the starting point for each student will significantly improve the equity of your grading scheme and mean that each student is graded relatively to their achievement in the class. Some people just aren't cut out to be compiler authors, but that doesn't mean they deserve an F - as long as they tried. If they don't give a crap, give them a 35 and move on to the next person.

	</p>
	
	<h2>Lexing & Parsing: Taking feedback</h2>
	
	<p>As a teacher, this can be one of the hardest parts. Personally, I've found that I really enjoy taking feedback from students - after all, they took the course, not me. Who am I to tell them how they should feel about it? But at the same time, it can be very frustrating to hear students complain about the course without grabbing them by the shoulders and going <i>if you'd just engaged with the material...</i> <b>How can you incorporate feedback from students (and others) into your course?</b> Most universities provide a mechanism for students to rate classes internally, and a common paradigm is to provide a minor grade boost - say, 0.25% - for filling this out, but only if 75% or above of the class do so. This can be useful, but at the same time is more common for larger classes. If you're taking a compilers course, it's because you know what you're getting into, most of the time. You'll most likely have heard about it from other students, not from an online review.

	<br><br>

	Additionally, online feedback tends to be pretty low-quality across the board. The combination of anonymous submission with poor timing - most students have either checked out completely by the time they fill out their surveys, or worse, are in the thick of their final project and never want to hear your name again - leads to surveys that are submitted half-empty, with numerical scores either at extremes or in the exact center. Often, the most valuable feedback you get comes from students who stop you in the hallways later in the year, or swing by your office hours, or who ask for mentorship advice. Those notes will be the ones that students have considered, weighed, and want to share with you. By definition, <i>there will be fewer of these</i>. That's okay! Semester over semester, year over year, you will accumulate these reviews and can hopefully use them to improve the way your course functions.

	<br><br>

	Another useful source of feedback can be other professors, students who aren't in your class, or even friends. It's easy to get bogged down in the notion that everyone in your course will understand what you're saying, and there's no better cure for that than sending a draft lecture about linker scripts to an old friend who works as an interior designer and asking her what she thinks. Some of the most common criticism of computer science courses is that they either assume far too much or far too little base knowledge; getting feedback from people with a wide range of base understanding is an excellent way to avoid these pitfalls.

	<br><br>

	The last thing to mention on this topic is that not every student will have a good experience. That's life. The important thing, much like how you grade, is that you make an effort to include each student and do your best to teach them all you can. Many of them will move on to be arborists, or graphic designers, or chefs, and will not be thinking about the syntax of <tt>lex</tt> and <tt>yacc</tt> day-to-day. If they can think back on your course fondly, in spite of that, then you've done all you can do.

	</p>

</body>
