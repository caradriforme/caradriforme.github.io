<head>
	<link rel="stylesheet" href="stylesheet.css">
	<title>Two: A-Normal Form & Context Expansion</title>
</head>

<body>
	<h2>A-Normal Form: Lining up student projects</h2>
	
	<p>So, you've introduced your class, you've gone over compiler structure, it's been a few weeks. Students have begun turning in their first couple of assignments. <b>How do you make sure your students stay on track, so that their later assignments can build on the earlier ones?</b> This is a tricky thing, much like being a Dungeon Master in D&D. You want your students to have as much freedom as they can get, without coloring so far outside the lines that they can't improve upon the situation they find themselves in. This can be accomplished in a number of ways.

	<ul>
		<li><b>Require students to complete the same assignments, the same way, until they reach their final.</b> This means that no matter what, your students will end up in the same place at the end of the course. Unfortunately, this restricts their creative freedom significantly. Often, some of the greatest joys of taking a capstone course involve getting to make your own decisions about how you can structure the project. At the same time, these guardrails ensure that your students can't get too far off track, and will simplify grading dramatically given that there's a floor on how bad their projects can be :)</li>
		<li><b>Give students free rein, as long as their code can pass a guaranteed minimum test suite.</b> This can work, and is often how first-year computer science courses are taught (much to the detriment of the course's TAs.) Having to grade and manage such a variety of codebases can make it very challenging to ensure that your students are able to continue progressing through the course. This is especially important when the course comprises but one project implemented over many parts, rather than the typical strategy of multiple smaller ones. At the same time, the creative freedom provided by the open assignments allows students to discover the inherent beauty of the intended solutions themselves while also providing the opportunity to understand the compiler's structure better through having to derive it themselves. </li>
		<li><b>Provide some kind of reference solution to a similar - but critically, different - problem.</b> I've been in classes where this approach has been taken before, and it can be helpful. Having a reference solution means you're not lost in the dark on how to implement the assigned task, but at the same time you're not just being handed the answer. The real issue with this one is that as the instructor, it means that not only do you have to write a reference solution for the assignment, you also have to write a reference for the students to work off of. In theory, at least, doubling your work beforehand lets you save a lot of time later on, since you can guarantee that your students are making progress in the right direction. This only works, of course, as long as you're able to write a reference solution that isn't either trivially related to the intended solution or one that is so far out-of-band that it's entirely unhelpful, which is a lot of work. </li>
		<li> And many others besides. </li>
	</ul>

	<br><br>

	This is one of the more important decisions you can make about your course, as it decides how your students will interact with your course over the majority of the semester. The important thing, more than anything else, is that you stick to your chosen method and commit to it. The worst feeling in the world, as a student, is to have a professor who chooses a method of grading and then doesn't put in the effort required to make it work as a grading solution. Giving your students confidence that they'll be able to complete the assignments in the time allotted will make them feel significantly better about the course as a whole.
	</p>
	
	<h2>Context Expansion: Going the extra mile</h2>
	
	<p>Your students have been working hard, meeting your milestones, asking interesting questions. But now it's time for them to choose and execute on their final projects. <b>How can you make sure your students will have final projects they can reasonably complete?</b> This is a difficult subject, but it ends up looking a lot like the question from the previous section. There are some minor differences that can be worthwhile to examine more closely. 

	<br><br>

	For starters, the final project is (or at least should be) much more open-ended than the individual assignments. This is a chance for your students to express their creativity and interests more broadly than they would otherwise be able to within the confines of a typical assignment. However, it's (extremely) important to temper their expectations and make sure their eyes don't get bigger than their proverbial stomachs. There is an argument to be made for allowing students to try whatever they want - as long as they make an attempt, that's good enough. The problem with this is that many students will pick a project idea that <i>seems</i> cool/interesting/easy, without then actually knowing how to implement it for the given structure. For this reason, the most common tactic is to require instructor approval for final projects. After all, in a capstone class you'll only have so many students, and it should be pretty reasonable to work with each one to make sure they're choosing something that would be appropriate for the amount of time and effort they should be expending.

	</p>

</body>
